/*
 * Helm Deployment Pipeline - Production Ready
 * Deploys to k3s cluster using Helm (Platform chart)
 * Structure: helm/platform/ (umbrella chart) + overlays/${ENV}/values.yaml
 */

pipeline {
    agent any
    
    parameters {
        choice(name: 'SERVICE', choices: ['all', 'auth', 'users', 'items', 'frontend'], description: 'Service to deploy (all = platform chart)')
        string(name: 'IMAGE_TAG', defaultValue: 'latest', description: 'Docker image tag')
        choice(name: 'ENVIRONMENT', choices: ['dev', 'staging', 'prod'], description: 'Target environment')
        booleanParam(name: 'DRY_RUN', defaultValue: true, description: 'Helm dry-run only')
    }
    
    environment {
        HELM_NAMESPACE = "${params.ENVIRONMENT}"
        PLATFORM_CHART_DIR = 'helm/platform'
        OVERLAYS_DIR = 'overlays'
        
        // k3s config - kubeconfig should be configured in Jenkins
        KUBECONFIG = "${env.KUBECONFIG ?: "${env.HOME}/.kube/config"}"
    }
    
    options {
        timeout(time: 30, unit: 'MINUTES')
        buildDiscarder(logRotator(numToKeepStr: '20'))
        timestamps()
    }
    
    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }
        
        stage('Validate') {
            steps {
                script {
                    echo "Service: ${params.SERVICE}"
                    echo "Image Tag: ${params.IMAGE_TAG}"
                    echo "Environment: ${params.ENVIRONMENT}"
                    echo "Namespace: ${HELM_NAMESPACE}"
                    
                    if (params.ENVIRONMENT == 'prod' && params.IMAGE_TAG == 'latest') {
                        error "Cannot deploy 'latest' tag to production"
                    }
                }
            }
        }
        
        stage('Helm Dependency Update') {
            steps {
                script {
                    def helmExists = sh(script: 'which helm', returnStatus: true) == 0
                    if (helmExists) {
                        sh """
                            cd ${PLATFORM_CHART_DIR}
                            helm dependency update
                        """
                    } else {
                        echo "Helm not installed - skipping dependency update"
                    }
                }
            }
        }
        
        stage('Helm Lint') {
            steps {
                script {
                    def helmExists = sh(script: 'which helm', returnStatus: true) == 0
                    if (helmExists) {
                        sh "helm lint ${PLATFORM_CHART_DIR}/"
                    } else {
                        echo "Helm not installed - skipping lint"
                    }
                }
            }
        }
        
        stage('Configure Kubernetes') {
            steps {
                script {
                    // Pour k3s, on utilise généralement un kubeconfig local
                    def kubeconfigPath = env.KUBECONFIG ?: "${env.HOME}/.kube/config"
                    
                    if (fileExists(kubeconfigPath)) {
                        echo "Using kubeconfig: ${kubeconfigPath}"
                        sh "export KUBECONFIG=${kubeconfigPath}"
                    } else {
                        echo "⚠️ KUBECONFIG not found at ${kubeconfigPath}"
                        echo "For k3s, ensure kubeconfig is configured in Jenkins credentials or environment"
                        echo "You can get k3s kubeconfig with: sudo cat /etc/rancher/k3s/k3s.yaml"
                    }
                    
                    // Vérifier la connexion
                    def kubectlExists = sh(script: 'which kubectl', returnStatus: true) == 0
                    if (kubectlExists) {
                        sh "kubectl cluster-info || true"
                        sh "kubectl get nodes || true"
                    }
                }
            }
        }
        
        stage('Create Namespace') {
            steps {
                script {
                    def kubectlExists = sh(script: 'which kubectl', returnStatus: true) == 0
                    def namespaceFile = "${OVERLAYS_DIR}/${params.ENVIRONMENT}/namespace.yaml"
                    
                    if (fileExists(namespaceFile) && kubectlExists) {
                        sh "kubectl apply -f ${namespaceFile}"
                    } else {
                        echo "Namespace file not found or kubectl not available - namespace will be created by Helm"
                    }
                }
            }
        }
        
        stage('Deploy Platform') {
            steps {
                script {
                    def helmExists = sh(script: 'which helm', returnStatus: true) == 0
                    def valuesFile = "${OVERLAYS_DIR}/${params.ENVIRONMENT}/values.yaml"
                    def dryRunFlag = params.DRY_RUN ? '--dry-run' : ''
                    
                    // Construire les --set pour mettre à jour les tags d'images selon le service
                    def setArgs = ""
                    
                    if (params.SERVICE == 'all') {
                        // Mettre à jour tous les services
                        setArgs = """
                            --set auth.image.tag=${params.IMAGE_TAG} \
                            --set users.image.tag=${params.IMAGE_TAG} \
                            --set items.image.tag=${params.IMAGE_TAG} \
                            --set frontend.image.tag=${params.IMAGE_TAG}
                        """
                    } else if (params.SERVICE == 'auth') {
                        setArgs = "--set auth.image.tag=${params.IMAGE_TAG}"
                    } else if (params.SERVICE == 'users') {
                        setArgs = "--set users.image.tag=${params.IMAGE_TAG}"
                    } else if (params.SERVICE == 'items') {
                        setArgs = "--set items.image.tag=${params.IMAGE_TAG}"
                    } else if (params.SERVICE == 'frontend') {
                        setArgs = "--set frontend.image.tag=${params.IMAGE_TAG}"
                    }
                    
                    if (helmExists) {
                        sh """
                            helm upgrade --install platform-${params.ENVIRONMENT} ${PLATFORM_CHART_DIR}/ \
                                --namespace ${HELM_NAMESPACE} \
                                --create-namespace \
                                -f ${valuesFile} \
                                ${setArgs} \
                                ${dryRunFlag}
                        """
                    } else {
                        echo "Would deploy platform to ${params.ENVIRONMENT}"
                        echo "Release: platform-${params.ENVIRONMENT}"
                        echo "Namespace: ${HELM_NAMESPACE}"
                        echo "Service: ${params.SERVICE}"
                        echo "Image tag: ${params.IMAGE_TAG}"
                    }
                }
            }
        }
        
        stage('Verify Deployment') {
            when {
                expression { return !params.DRY_RUN }
            }
            steps {
                script {
                    def kubectlExists = sh(script: 'which kubectl', returnStatus: true) == 0
                    if (kubectlExists) {
                        sh """
                            kubectl get pods -n ${HELM_NAMESPACE}
                            kubectl get svc -n ${HELM_NAMESPACE}
                        """
                    }
                }
            }
        }
    }
    
    post {
        success {
            echo "Helm deploy completed - Service: ${params.SERVICE}, Env: ${params.ENVIRONMENT}, Tag: ${params.IMAGE_TAG}"
        }
        failure {
            echo "Helm deploy failed"
        }
    }
}
